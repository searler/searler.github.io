---
layout: post
title:  "Using Akka CircuitBreaker with Akka Reactive Streams"
date:   2015-06-14 16:20:00
categories:  scala akka reactive streams
---

The Akka [CircuitBreaker](http://doc.akka.io/docs/akka/snapshot/common/circuitbreaker.html)
can be combined with Reactive Streams as follows.

The core of the process is 

```scala
 .mapAsync(6) { x =>
      (lookup ? x) recover {
        case e: CircuitBreakerOpenException => "open"
        case _@ x                           => x.toString
      }
    }
```
which:

1. requests a result from the lookup actor.
2. Replaces the exception generated by open CB with the value "open".
3. Converts an other result to its string representation.

The output is

```
AA
B
java.lang.IllegalArgumentException: xxxxxxxxxxxxxxxx
open
open
open
```

The runnable application code

{% highlight scala %}
import scala.collection.immutable.Seq
import scala.concurrent.Future
import scala.concurrent.duration.DurationInt
import akka.actor.Actor
import akka.actor.ActorLogging
import akka.actor.ActorSystem
import akka.actor.Props
import akka.pattern.CircuitBreaker
import akka.pattern.ask
import akka.pattern.pipe
import akka.stream.ActorFlowMaterializer
import akka.stream.scaladsl.Source
import akka.util.Timeout
import akka.pattern.CircuitBreakerOpenException

object AkkaCB extends App {

  class DangerousActor extends Actor with ActorLogging {
    import context.dispatcher

    val breaker =
      new CircuitBreaker(context.system.scheduler,
        maxFailures = 1,
        callTimeout = 10.seconds,
        resetTimeout = 1.minute).onOpen(notifyMeOnOpen())

    def notifyMeOnOpen(): Unit =
      log.warning("My CircuitBreaker is now open, and will not close for one minute")

    def rejectMoreThanTwo(s: String): String =
      if (s.length > 2)
        throw new IllegalArgumentException(s);
      else
        s

    def receive = {
      case s: String =>
        breaker.withCircuitBreaker(Future(rejectMoreThanTwo(s))) pipeTo sender()

    }
  }

  implicit val system = ActorSystem("Sys")
  import system.dispatcher
  implicit val materializer = ActorFlowMaterializer()

  val lookup = system.actorOf(Props[DangerousActor])

  implicit val timeout = Timeout(3.seconds)
  val r = Source.apply(Seq("AA", "B", "xxxxxxxxxxxxxxxx", "Ced", "Dxxx", "E"))
    .mapAsync(6) { x =>
      (lookup ? x) recover {
        case e: CircuitBreakerOpenException => "open"
        case _@ x                           => x.toString
      }
    }
    .runForeach(println)

  r.onComplete {
    case x @ _ => println(x); system.shutdown
  }

}
{% endhighlight %}








